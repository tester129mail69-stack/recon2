"""Vulnerability detection module for GODRECON.

Scans the root target AND every discovered subdomain (from shared store).
Multi-source CVE lookup (NVD + CIRCL + OSV) + pattern matching +
real-time Telegram alerts for critical/high findings.
"""

from __future__ import annotations

import asyncio
import time
from typing import Any, Dict, List, Optional, Tuple

from godrecon.core.config import Config
from godrecon.modules.base import BaseModule, Finding, ModuleResult
from godrecon.modules.vulns.cve_lookup import CVELookup
from godrecon.modules.vulns.pattern_matcher import PatternMatcher
from godrecon.modules.vulns.posture import SecurityPostureScorer
from godrecon.utils.http_client import AsyncHTTPClient
from godrecon.utils.logger import get_logger
from godrecon.utils.telegram_notifier import TelegramNotifier, get_notifier_from_config

logger = get_logger(__name__)

_DEFAULT_CONCURRENCY        = 30
_DEFAULT_MAX_CVE_RESULTS    = 100
_DEFAULT_SAFE_MODE          = True
_DEFAULT_SEVERITY_THRESHOLD = "info"
_TECH_WAIT_TIMEOUT          = 30.0
_TECH_WAIT_INTERVAL         = 0.5
_SUBDOMAIN_WAIT_TIMEOUT     = 60.0
_SUBDOMAIN_WAIT_INTERVAL    = 1.0
# Max concurrent subdomain vuln scans to avoid hammering everything at once
_SUBDOMAIN_SCAN_CONCURRENCY = 5


class VulnerabilityModule(BaseModule):
    """Vulnerability detection: CVE lookup + pattern matching on root + all subdomains."""

    name        = "vulns"
    description = "Multi-source CVE lookup (NVD+CIRCL+OSV), pattern matching on root + all subdomains"
    author      = "GODRECON Team"
    version     = "4.0.0"
    category    = "vulns"

    async def _execute(self, target: str, config: Config) -> ModuleResult:
        result    = ModuleResult(module_name=self.name, target=target)
        vulns_cfg = getattr(config, "vulns", None)

        enabled_cve        = getattr(vulns_cfg, "cve_lookup",        True)
        enabled_patterns   = getattr(vulns_cfg, "pattern_matching",  True)
        enabled_posture    = getattr(vulns_cfg, "posture_scoring",    True)
        max_cve            = getattr(vulns_cfg, "max_cve_results",    _DEFAULT_MAX_CVE_RESULTS)
        safe_mode          = getattr(vulns_cfg, "safe_mode",          _DEFAULT_SAFE_MODE)
        severity_threshold = getattr(vulns_cfg, "severity_threshold", _DEFAULT_SEVERITY_THRESHOLD)

        general     = config.general
        timeout     = general.timeout
        proxy       = general.proxy
        user_agents = general.user_agents

        notifier: Optional[TelegramNotifier] = get_notifier_from_config(config)
        if notifier:
            await notifier.alert_scan_started(target)

        # ── Wait for subdomain module to populate shared store ──────────
        all_targets = await self._wait_for_subdomains(target)
        logger.info(
            "Vuln scanning %d targets for %s (root + %d subdomains)",
            len(all_targets), target, len(all_targets) - 1,
        )

        # ── Run scans ───────────────────────────────────────────────────
        all_cve_findings:     List[Dict[str, Any]] = []
        all_pattern_findings: List[Dict[str, Any]] = []

        async with AsyncHTTPClient(
            timeout=timeout,
            max_connections=_DEFAULT_CONCURRENCY,
            user_agents=user_agents,
            proxy=proxy,
            verify_ssl=False,
            retries=1,
            rate_limit=0.0,
        ) as http:
            # Semaphore limits how many subdomains we scan at once
            sem = asyncio.Semaphore(_SUBDOMAIN_SCAN_CONCURRENCY)

            async def _scan_one(t: str) -> Tuple[
                List[Dict[str, Any]], List[Dict[str, Any]]
            ]:
                async with sem:
                    return await self._scan_target(
                        http=http,
                        target=t,
                        root_target=target,
                        enabled_cve=enabled_cve,
                        enabled_patterns=enabled_patterns,
                        max_cve=max_cve,
                        safe_mode=safe_mode,
                        severity_threshold=severity_threshold,
                        config=config,
                    )

            scan_results = await asyncio.gather(
                *[_scan_one(t) for t in all_targets],
                return_exceptions=True,
            )

        for i, res in enumerate(scan_results):
            t = all_targets[i]
            if isinstance(res, Exception):
                logger.warning("Scan failed for %s: %s", t, res)
                continue
            cve_f, pat_f = res
            all_cve_findings.extend(cve_f)
            all_pattern_findings.extend(pat_f)

        # ── Build findings ──────────────────────────────────────────────
        for cve in all_cve_findings:
            result.findings.append(self._cve_to_finding(cve, cve.get("_scanned_target", target)))

        for match in all_pattern_findings:
            result.findings.append(self._match_to_finding(match))

        # ── Posture scoring ─────────────────────────────────────────────
        posture: Optional[Dict[str, Any]] = None
        if enabled_posture:
            try:
                scorer = SecurityPostureScorer({self.name: result})
                posture = scorer.score()
                result.findings.append(self._posture_to_finding(posture))
            except Exception as exc:
                logger.warning("Posture scoring failed: %s", exc)

        # ── Telegram alerts ─────────────────────────────────────────────
        if notifier:
            await self._send_telegram_alerts(
                notifier, target, all_cve_findings, all_pattern_findings, config
            )

        result.raw = {
            "cve_findings":          all_cve_findings,
            "pattern_matches":       all_pattern_findings,
            "posture":               posture,
            "targets_scanned":       all_targets,
            "total_targets":         len(all_targets),
            "total_cves":            len(all_cve_findings),
            "total_pattern_matches": len(all_pattern_findings),
        }

        logger.info(
            "Vuln scan complete — %d targets, %d CVEs, %d pattern matches, %d total findings",
            len(all_targets),
            len(all_cve_findings),
            len(all_pattern_findings),
            len(result.findings),
        )
        return result

    # ──────────────────────────────────────────────────────────────────────
    # Subdomain store helpers
    # ──────────────────────────────────────────────────────────────────────

    @staticmethod
    async def _wait_for_subdomains(target: str) -> List[str]:
        """Wait for subdomain module then return root + all live subdomains."""
        try:
            from godrecon.modules.subdomains import get_discovered_subdomains
        except ImportError:
            logger.debug("Subdomain shared store not available — scanning root only")
            return [target]

        deadline = time.monotonic() + _SUBDOMAIN_WAIT_TIMEOUT
        while time.monotonic() < deadline:
            subs = get_discovered_subdomains(target)
            if subs:
                # Ensure root target is always first
                all_t = [target] + [s for s in subs if s != target]
                logger.info(
                    "Subdomain store ready — %d targets to scan for %s",
                    len(all_t), target,
                )
                return all_t
            await asyncio.sleep(_SUBDOMAIN_WAIT_INTERVAL)

        logger.info(
            "Subdomain store wait timed out for %s — scanning root only", target
        )
        return [target]

    # ──────────────────────────────────────────────────────────────────────
    # Per-target scan
    # ──────────────────────────────────────────────────────────────────────

    async def _scan_target(
        self,
        http: AsyncHTTPClient,
        target: str,
        root_target: str,
        enabled_cve: bool,
        enabled_patterns: bool,
        max_cve: int,
        safe_mode: bool,
        severity_threshold: str,
        config: Config,
    ) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
        """Run CVE lookup + pattern matching against a single target."""
        logger.info("Scanning target: %s", target)

        # Get tech for this specific subdomain
        technologies = await self._get_tech_for_target(http, target, root_target)
        logger.info(
            "%s — %d technologies detected", target, len(technologies)
        )

        cve_findings:     List[Dict[str, Any]] = []
        pattern_findings: List[Dict[str, Any]] = []

        tasks = []
        if enabled_cve:
            tasks.append(asyncio.create_task(
                self._run_cve_lookup(http, target, technologies, max_cve, config)
            ))
        if enabled_patterns:
            tasks.append(asyncio.create_task(
                self._run_pattern_matcher(
                    http, target, safe_mode, severity_threshold, technologies
                )
            ))

        task_results = await asyncio.gather(*tasks, return_exceptions=True)

        idx = 0
        if enabled_cve:
            r = task_results[idx]; idx += 1
            if isinstance(r, list):
                # Tag each CVE finding with which subdomain it came from
                for item in r:
                    item["_scanned_target"] = target
                cve_findings = r
            elif isinstance(r, Exception):
                logger.warning("CVE lookup failed for %s: %s", target, r)

        if enabled_patterns:
            r = task_results[idx]; idx += 1
            if isinstance(r, list):
                pattern_findings = r
            elif isinstance(r, Exception):
                logger.warning("Pattern matching failed for %s: %s", target, r)

        if cve_findings or pattern_findings:
            logger.info(
                "✓ %s — %d CVEs, %d pattern matches",
                target, len(cve_findings), len(pattern_findings),
            )

        return cve_findings, pattern_findings

    # ──────────────────────────────────────────────────────────────────────
    # Tech detection helpers
    # ──────────────────────────────────────────────────────────────────────

    @staticmethod
    async def _get_tech_for_target(
        http: AsyncHTTPClient,
        target: str,
        root_target: str,
    ) -> List[Dict[str, Any]]:
        """Get detected tech for target — shared store first, then fingerprint."""
        # Try shared store (populated by tech module for root target)
        try:
            from godrecon.modules.tech.scanner import get_detected_tech
            # Try exact match first
            techs = get_detected_tech(target)
            if techs:
                return techs
            # For subdomains fall back to root target tech as starting point
            if target != root_target:
                techs = get_detected_tech(root_target)
                if techs:
                    return techs
        except ImportError:
            pass

        # Fall back to live fingerprint for this subdomain
        return await VulnerabilityModule._fallback_fingerprint(http, target)

    @staticmethod
    async def _fallback_fingerprint(
        http: AsyncHTTPClient, target: str
    ) -> List[Dict[str, Any]]:
        try:
            from godrecon.modules.tech.fingerprint import TechFingerprinter
            for scheme in ("https", "http"):
                try:
                    resp = await http.get(f"{scheme}://{target}", allow_redirects=True)
                    if not resp:
                        continue
                    headers = {k.lower(): v for k, v in (resp.get("headers") or {}).items()}
                    body    = resp.get("body") or ""
                    cookies = headers.get("set-cookie", "")
                    fp      = TechFingerprinter(
                        headers=headers, body=body, cookies=cookies,
                        url=f"{scheme}://{target}",
                    )
                    techs = fp.fingerprint()
                    if techs:
                        logger.info(
                            "Fingerprint found %d techs on %s", len(techs), target
                        )
                        return techs
                except Exception:
                    continue
        except Exception as exc:
            logger.debug("Fingerprint error for %s: %s", target, exc)
        return []

    # ──────────────────────────────────────────────────────────────────────
    # Sub-module runners
    # ──────────────────────────────────────────────────────────────────────

    async def _run_cve_lookup(
        self,
        http: AsyncHTTPClient,
        target: str,
        technologies: List[Dict[str, Any]],
        max_cve: int,
        config: Config,
    ) -> List[Dict[str, Any]]:
        if not technologies:
            return []

        nvd_api_key = getattr(getattr(config, "api_keys", None), "nvd", None) or None
        lookup = CVELookup(
            http_client=http,
            max_results=max_cve,
            nvd_api_key=nvd_api_key,
        )
        cves = await lookup.lookup_technologies(technologies)

        if cves:
            logger.info("Found %d CVEs on %s", len(cves), target)
            for cve in cves[:10]:
                logger.info(
                    "  [%s] %s | %s %s | CVSS:%s",
                    target,
                    cve.get("id", "?"),
                    cve.get("technology", "?"),
                    cve.get("detected_version", ""),
                    cve.get("cvss", "?"),
                )
        return cves

    async def _run_pattern_matcher(
        self,
        http: AsyncHTTPClient,
        target: str,
        safe_mode: bool,
        severity_threshold: str,
        technologies: List[Dict[str, Any]],
    ) -> List[Dict[str, Any]]:
        base_url = f"https://{target}" if not target.startswith("http") else target
        matcher  = PatternMatcher(
            http_client=http,
            concurrency=_DEFAULT_CONCURRENCY,
            safe_mode=safe_mode,
            severity_threshold=severity_threshold,
            detected_tech=technologies,
        )

        matches = await matcher.run(base_url)

        # Retry on HTTP if HTTPS returned nothing
        if not matches:
            http_base = f"http://{target}" if not target.startswith("http") else target
            if http_base != base_url:
                matches = await matcher.run(http_base)

        return matches

    # ──────────────────────────────────────────────────────────────────────
    # Telegram alerts
    # ──────────────────────────────────────────────────────────────────────

    @staticmethod
    async def _send_telegram_alerts(
        notifier: TelegramNotifier,
        target: str,
        cve_findings: List[Dict[str, Any]],
        pattern_findings: List[Dict[str, Any]],
        config: Config,
    ) -> None:
        if cve_findings:
            await notifier.alert_bulk_cves(cve_findings, target)

        for cve in cve_findings:
            if cve.get("severity") in ("critical", "high"):
                await notifier.alert_cve_found(cve, target)
                await asyncio.sleep(0.3)

        for match in pattern_findings:
            if match.get("severity") in ("critical", "high"):
                await notifier.alert_vuln_found(match, target)
                await asyncio.sleep(0.3)

        total = len(cve_findings) + len(pattern_findings)
        await notifier.alert_scan_finished(
            target, total, {"modules_run": 1, "duration_seconds": 0}
        )

    # ──────────────────────────────────────────────────────────────────────
    # Finding builders
    # ──────────────────────────────────────────────────────────────────────

    @staticmethod
    def _cve_to_finding(cve: Dict[str, Any], target: str) -> Finding:
        cve_id    = cve.get("id", "Unknown CVE")
        tech      = cve.get("technology", "unknown")
        version   = cve.get("detected_version", "")
        summary   = cve.get("summary", "No description available")
        cvss      = cve.get("cvss", 0.0)
        severity  = cve.get("severity", "info")
        cwe       = cve.get("cwe", "")
        refs      = cve.get("references", [])
        affected  = cve.get("affected_versions", [])
        published = cve.get("published", "")
        source    = cve.get("source", "")

        version_str = f" {version}" if version and version != "unknown" else ""

        desc_lines = [
            f"CVE ID:     {cve_id}",
            f"Target:     {target}",
            f"Technology: {tech}{version_str}",
            f"CVSS Score: {cvss}",
            f"Severity:   {severity.upper()}",
            f"Source:     {source}",
        ]
        if cwe:
            desc_lines.append(f"CWE:        {cwe}")
        if published:
            desc_lines.append(f"Published:  {published}")
        if affected:
            desc_lines.append(f"Affected:   {', '.join(affected[:5])}")
        if summary:
            desc_lines.append(f"\nSummary: {summary}")
        if refs:
            desc_lines.append("\nReferences:")
            for ref in refs[:5]:
                desc_lines.append(f"  - {ref}")

        return Finding(
            title=f"{cve_id} — {tech}{version_str} @ {target}",
            description="\n".join(desc_lines),
            severity=severity,
            data=cve,
            tags=["cve", "vulnerability", tech.lower(), cve_id, source.lower()],
        )

    @staticmethod
    def _match_to_finding(match: Dict[str, Any]) -> Finding:
        name        = match.get("name", "Unknown Template")
        category    = match.get("category", "")
        url         = match.get("url", "")
        severity    = match.get("severity", "info")
        remediation = match.get("remediation", "")
        template_id = match.get("template_id", "")
        method      = match.get("method", "GET")
        status_code = match.get("status_code", "")
        confirmed   = match.get("confirmed", False)
        note        = match.get("note", "")

        desc_lines = [
            f"Template:    {template_id}",
            f"URL:         {url}",
            f"Method:      {method}",
            f"Confirmed:   {'YES' if confirmed else 'POTENTIAL - verify manually'}",
        ]
        if status_code:
            desc_lines.append(f"Status:      {status_code}")
        if category:
            desc_lines.append(f"Category:    {category}")
        if note:
            desc_lines.append(f"Note:        {note}")
        if remediation:
            desc_lines.append(f"Remediation: {remediation}")

        return Finding(
            title=f"[{severity.upper()}] {name}: {url}",
            description="\n".join(desc_lines),
            severity=severity,
            data=match,
            tags=["pattern-match", category, "vulnerability",
                  "confirmed" if confirmed else "potential"],
        )

    @staticmethod
    def _posture_to_finding(posture: Dict[str, Any]) -> Finding:
        score   = posture.get("overall_score", 0)
        grade   = posture.get("grade", "?")
        summary = posture.get("summary", "")
        if score >= 90:
            severity = "info"
        elif score >= 70:
            severity = "low"
        elif score >= 50:
            severity = "medium"
        else:
            severity = "high"
        return Finding(
            title=f"Security Posture Score: {score}/100 (Grade {grade})",
            description=summary,
            severity=severity,
            data=posture,
            tags=["posture", "score", "summary"],
        )
